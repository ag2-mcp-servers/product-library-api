# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:56:06+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Header, Path, Query
from pydantic import conint

from models import (
    BulkImportRequest,
    CategoryResponse,
    CreateCategoriesRequest,
    CreateSlugRequest,
    DiscountRequest,
    DiscountResponse,
    ErrorResponse,
    FullProductUpdateRequest,
    ImportResponse,
    LibraryImagesResponse,
    LibraryResponse,
    OrganizationsOrganizationUuidDiscountsGetResponse,
    OrganizationsOrganizationUuidProductsGetResponse,
    OrganizationsOrganizationUuidProductsOptionsGetResponse,
    OrganizationsOrganizationUuidProductsV2CountGetResponse,
    OrganizationsOrganizationUuidProductsV2GetResponse,
    ProductCreateRequest,
    ProductResponse,
    RenameCategoryRequest,
    SlugResponse,
    TaxRate,
    TaxRateProductCountResponse,
    TaxRatesCreateRequest,
    TaxRatesResponse,
    TaxRateUpdateRequest,
    TaxSettingsResponse,
    TaxSettingsUpdateRequest,
    Uuid,
    V1TaxesGetResponse,
)

app = MCPProxy(
    description="The Product Library API is used for managing merchant's product information and product images.",
    title='Product Library API',
    version='1.0.0',
    servers=[
        {
            'description': 'Production',
            'url': 'https://products.izettle.com',
            'variables': {},
        }
    ],
)


@app.get(
    '/organizations/{organizationUuid}/categories/v2',
    tags=['category_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_product_types(organization_uuid: UUID = Path(..., alias='organizationUuid')):
    """
    Retrieve all categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/{organizationUuid}/categories/v2',
    tags=['category_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_categories(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    body: CreateCategoriesRequest = ...,
):
    """
    Create a new category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/{organizationUuid}/categories/v2/{categoryUuid}',
    tags=['category_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_category(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    category_uuid: UUID = Path(..., alias='categoryUuid'),
):
    """
    Delete a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/organizations/{organizationUuid}/categories/v2/{categoryUuid}',
    tags=['category_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def rename_category(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    category_uuid: UUID = Path(..., alias='categoryUuid'),
    body: RenameCategoryRequest = ...,
):
    """
    Rename a category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/discounts',
    tags=['discount_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_all_discounts(organization_uuid: UUID = Path(..., alias='organizationUuid')):
    """
    Retrieve all discounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/{organizationUuid}/discounts',
    description=""" Creates a single discount entity. The location of the newly created discount will be available in the successful response as a HttpHeaders.LOCATION header """,
    tags=['discount_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_discount(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    body: DiscountRequest = None,
):
    """
    Create a discount
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/{organizationUuid}/discounts/{discountUuid}',
    tags=['discount_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_discount(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    discount_uuid: UUID = Path(..., alias='discountUuid'),
):
    """
    Delete a single discount
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/discounts/{discountUuid}',
    description=""" Get the full discount with the provided UUID. The method supports conditional GET through providing a HttpHeaders.IF_NONE_MATCH header. If the conditional prerequisite is fullfilled, the full discount is returned: otherwise a 304 not modified will be returned with an empty body. """,
    tags=['discount_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_discount(
    if__none__match: Optional[str] = Header(None, alias='If-None-Match'),
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    discount_uuid: UUID = Path(..., alias='discountUuid'),
):
    """
    Retrieve a single discount
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/organizations/{organizationUuid}/discounts/{discountUuid}',
    description=""" Updates a discount entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field. Conditional updates are supported through the HttpHeaders.IF_MATCH header. If the conditional prerequisite is fullfilled, the discount is updated: otherwise a 412 precondition failed will be returned with an empty body. """,
    tags=['discount_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_discount(
    if__match: Optional[str] = Header(None, alias='If-Match'),
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    discount_uuid: UUID = Path(..., alias='discountUuid'),
    body: DiscountRequest = ...,
):
    """
    Update a single discount
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/images',
    description=""" Retrieves all library items images used by the organization, sorted by updated date """,
    tags=['library_item_retrieval', 'library_import_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_all_image_urls(organization_uuid: UUID = Path(..., alias='organizationUuid')):
    """
    Retrieve all library item images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/import/status',
    tags=['library_import_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_latest_import_status(
    organization_uuid: UUID = Path(..., alias='organizationUuid')
):
    """
    Get status for latest import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/import/status/{importUuid}',
    tags=['library_import_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_status_by_uuid(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    import_uuid: UUID = Path(..., alias='importUuid'),
):
    """
    Get status for an import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/{organizationUuid}/import/v2',
    tags=['library_import_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def import_library_v2(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    body: BulkImportRequest = ...,
):
    """
    Import library items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/library',
    description=""" Will return the entire library for the authenticated user. If size of the library exceeds server preferences (normally 500) or the value of the optional limit parameter, the result will be paginated. Paginated responses return a Link header, indicating the next URI to fetch. The resulting header value will look something like:

<https://products.izettle.com/organizations/self/library?limit=X&offset=Y>; rel="next"

where limit is number of items in response, and offset is the current position in pagination. The rel-part in the header is the links relation to the data previously recieved. The idea is that as long as this header is present there are still items remaining to be fetched. When either the header is not present or it's value doesn't contain any "next" value, all items have been sent to the client.

Note: The client should NOT try to extract query parameters from the URI, but rather use it as-is for the next request. Also, clients should be perpared that one Link header might contain multiple other IRIs that are not "next" (there will never be more than one "next" though). See more at:

    IETF: https://tools.ietf.org/html/rfc5988
    GitHub: https://developer.github.com/guides/traversing-with-pagination/

If eventLogUuid is provided, the response will only include events affecting the library since that event. Such responses are normally quite small and would be a preferred method for most fat clients after retrieving the initial full library.
 """,
    tags=['library_item_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_library(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    event_log_uuid: Optional[UUID] = Query(None, alias='eventLogUuid'),
    limit: Optional[conint(ge=1, le=500)] = 500,
    offset: Optional[str] = None,
    all: Optional[bool] = None,
):
    """
    Retrieve the entire library
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/{organizationUuid}/products',
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_products(
    organization_uuid: UUID = Path(..., alias='organizationUuid'), uuid: Uuid = ...
):
    """
    Delete a list of products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/products',
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_all_products_in_pos(
    organization_uuid: UUID = Path(..., alias='organizationUuid')
):
    """
    Retrieve all products visible in POS
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/{organizationUuid}/products',
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_product(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    return_entity: Optional[bool] = Query(False, alias='returnEntity'),
    body: ProductCreateRequest = ...,
):
    """
    Create a new product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/{organizationUuid}/products/online/slug',
    description=""" Creates a unique slug (identifier) for a product. The slug is used to create a product URL """,
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_product_slug(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    body: CreateSlugRequest = ...,
):
    """
    Create a product identifier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/products/options',
    tags=['library_item_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_all_options(organization_uuid: UUID = Path(..., alias='organizationUuid')):
    """
    Retrieve an aggregate of active Options in the library
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/products/v2',
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_all_products_v2(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    sort: Optional[bool] = None,
):
    """
    Retrieve all products visible in POS – v2
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/products/v2/count',
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def count_all_products(organization_uuid: UUID = Path(..., alias='organizationUuid')):
    """
    Retrieve the count of existing products
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/organizations/{organizationUuid}/products/v2/{productUuid}',
    description=""" Updates a product entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field. Conditional updates are supported through the HttpHeaders.IF_MATCH header. If the conditional prerequisite is fullfilled, the product is updated: otherwise a 412 (precondition failed) will be returned with an empty body. """,
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_product(
    if__match: Optional[str] = Header(None, alias='If-Match'),
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    product_uuid: UUID = Path(..., alias='productUuid'),
    body: FullProductUpdateRequest = ...,
):
    """
    Update a single product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/{organizationUuid}/products/{productUuid}',
    tags=['product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_product(
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    product_uuid: UUID = Path(..., alias='productUuid'),
):
    """
    Delete a single product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/{organizationUuid}/products/{productUuid}',
    description=""" Get the full product with the provided UUID. The method supports conditional GET through providing a HttpHeaders.IF_NONE_MATCH header. If the conditional prerequisite is fullfilled, the full product is returned, otherwise a 304 not modified will be returned with an empty body. """,
    tags=['product_management', 'library_item_retrieval'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_product(
    if__none__match: Optional[str] = Header(None, alias='If-None-Match'),
    organization_uuid: UUID = Path(..., alias='organizationUuid'),
    product_uuid: UUID = Path(..., alias='productUuid'),
):
    """
    Retrieve a single product
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/taxes',
    tags=['tax_management', 'tax_rate_update'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tax_rates():
    """
    Get all available tax rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/taxes',
    tags=['tax_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tax_rates(body: TaxRatesCreateRequest):
    """
    Create new tax rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/taxes/count',
    tags=['tax_management', 'tax_rate_update', 'product_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_product_count_for_all_taxes():
    """
    Get all tax rates and a count of products associated with each
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/taxes/settings',
    tags=['tax_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tax_settings():
    """
    Get the organization tax settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/taxes/settings',
    tags=['tax_management', 'tax_rate_update'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def set_taxation_mode(body: TaxSettingsUpdateRequest):
    """
    Update the organization tax settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/taxes/{taxRateUuid}',
    tags=['tax_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_tax_rate(tax_rate_uuid: UUID = Path(..., alias='taxRateUuid')):
    """
    Delete a single tax rate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/taxes/{taxRateUuid}',
    tags=['tax_management', 'tax_rate_update'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tax_rate(tax_rate_uuid: UUID = Path(..., alias='taxRateUuid')):
    """
    Get a single tax rate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/taxes/{taxRateUuid}',
    tags=['tax_management', 'tax_rate_update'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_tax_rate(
    tax_rate_uuid: UUID = Path(..., alias='taxRateUuid'),
    body: TaxRateUpdateRequest = ...,
):
    """
    Update a single tax rate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
